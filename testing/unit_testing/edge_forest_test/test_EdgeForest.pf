module test_EdgeForest
  !
  ! DESCRIPTION:
  !  Test the FATES edge forest code
  !
  use FatesConstantsMod, only : r8 => fates_r8, nearzero
  use FatesEdgeForestMod, only : indexx
  use FatesEdgeForestMod, only : GetFracEdgeForestInEachBin
  use FatesEdgeForestMod, only : GetFracEdgeForestInEachBin_norm_numerator, GetFracEdgeForestInEachBin_norm_denominator, GetFracEdgeForestInEachBin_quadratic
  use FatesEdgeForestMod, only : GetFracEdgeForestInEachBin_norm
  use FatesEdgeForestMod, only : AssignPatchToBins
  use FatesEdgeForestMod, only : calculate_edgeforest_flammability_onevar_onebin
  use FatesEdgeForestMod, only : calculate_edgeforest_flammability_onevar
  use FatesEdgeForestMod, only : apply_edgeforest_flammability_to_patch_onevar
  use FatesEdgeForestMod, only : check_change_intended
  use funit

  implicit none

  @TestCase
  type, extends(TestCase) :: TestEdgeForest

    real(r8), dimension(:), allocatable :: array_to_sort
    integer, dimension(:), allocatable  :: sorted_indices

    contains
      procedure :: setUp
      procedure :: tearDown
  end type TestEdgeForest

  real(r8), parameter :: tol = 1.e-7_r8
  real(r8), parameter :: nan = 0._r8 / 0._r8

  integer, parameter :: n_to_sort = 5


  contains

    subroutine setUp(this)
      class(TestEdgeForest), intent(inout) :: this
      allocate(this%array_to_sort(n_to_sort))
      allocate(this%sorted_indices(n_to_sort))
    end subroutine setUp

    subroutine tearDown(this)
      class(TestEdgeForest), intent(inout) :: this
      if (allocated(this%array_to_sort)) deallocate(this%array_to_sort)
      if (allocated(this%sorted_indices)) deallocate(this%sorted_indices)
    end subroutine tearDown

    @Test
    subroutine indexx_alreadySorted(this)
      class(TestEdgeForest), intent(inout) :: this

      this%array_to_sort = (/ 1._r8, 1.62_r8, 2.72_r8, 3.14_r8, 6.28_r8 /)

      call indexx(this%array_to_sort, this%sorted_indices)

      @assertEqual((/ 1, 2, 3, 4, 5 /), this%sorted_indices)

    end subroutine indexx_alreadySorted

    @Test
    subroutine indexx_reverseSorted(this)
      class(TestEdgeForest), intent(inout) :: this

      this%array_to_sort = (/ 6.28_r8, 3.14_r8, 2.72_r8, 1.62_r8, 1._r8 /)

      call indexx(this%array_to_sort, this%sorted_indices)

      @assertEqual((/ 5, 4, 3, 2, 1 /), this%sorted_indices)

    end subroutine indexx_reverseSorted

    @Test
    subroutine indexx_lowTie(this)
      class(TestEdgeForest), intent(inout) :: this

      this%array_to_sort = (/ 1._r8, 1._r8, 2.72_r8, 3.14_r8, 6.28_r8 /)

      call indexx(this%array_to_sort, this%sorted_indices)

      @assertEqual((/ 1, 2, 3, 4, 5 /), this%sorted_indices)

    end subroutine indexx_lowTie

    @Test
    subroutine indexx_highTie(this)
      class(TestEdgeForest), intent(inout) :: this

      this%array_to_sort = (/ 1._r8, 1.62_r8, 2.72_r8, 3.14_r8, 3.14_r8 /)

      call indexx(this%array_to_sort, this%sorted_indices)

      @assertEqual((/ 1, 2, 3, 4, 5 /), this%sorted_indices)

    end subroutine indexx_highTie

    @Test
    subroutine indexx_random(this)
      class(TestEdgeForest), intent(inout) :: this

      this%array_to_sort = (/ 3._r8, 8._r8, 10._r8, 2._r8, 7._r8 /)

      call indexx(this%array_to_sort, this%sorted_indices)

      @assertEqual((/ 4, 1, 5, 2, 3 /), this%sorted_indices)

    end subroutine indexx_random


    @Test
    subroutine indexx_all_equal(this)
      class(TestEdgeForest), intent(inout) :: this

      this%array_to_sort = (/ 1._r8, 1._r8, 1._r8, 1._r8, 1._r8 /)

      call indexx(this%array_to_sort, this%sorted_indices)

      @assertEqual((/ 1, 2, 3, 4, 5 /), this%sorted_indices)

    end subroutine indexx_all_equal


    @Test
    subroutine test_GetFracEdgeForestInEachBin_with_gaussian(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = 0.5_r8
      integer, parameter :: nlevedgeforest_tmp = 1
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_amplitude = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_sigma = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_center = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_nan = (/ nan /)
      logical :: norm = .false.  ! DON'T normalize; we want the raw output of Gaussian
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_amplitude, efb_params_sigma, efb_params_center, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           fraction_forest_in_bin, norm)

      @assertEqual(0.3520653267642879_r8, fraction_forest_in_bin(1), tol)

    end subroutine test_GetFracEdgeForestInEachBin_with_gaussian


    @Test
    subroutine test_GetFracEdgeForestInEachBin_with_lognorm(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = 0.5_r8
      integer, parameter :: nlevedgeforest_tmp = 1
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_amplitude = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_sigma = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_center = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_nan = (/ nan /)
      logical :: norm = .false.  ! DON'T normalize; we want the raw output of Lognormal
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           efb_params_amplitude, efb_params_sigma, efb_params_center, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           fraction_forest_in_bin, norm)

      @assertEqual(0.19029780481010555, fraction_forest_in_bin(1), tol)

    end subroutine test_GetFracEdgeForestInEachBin_with_lognorm


    @Test
    subroutine test_GetFracEdgeForestInEachBin_with_quadratic(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = 0.5_r8
      integer, parameter :: nlevedgeforest_tmp = 1
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_a = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_b = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_c = (/ 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_nan = (/ nan /)
      logical :: norm = .false.  ! DON'T normalize; we want the raw output of Quadratic
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           efb_params_a, efb_params_b, efb_params_c, &
           fraction_forest_in_bin, norm)

      @assertEqual(1.75, fraction_forest_in_bin(1), tol)

    end subroutine test_GetFracEdgeForestInEachBin_with_quadratic


    @Test
    subroutine test_GetFracEdgeForestInEachBin_with_norm(this)
      ! Test that normalization works correctly: If all bins have the same parameters, they should
      ! get normalized to 1/nbins.
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = 0.5_r8
      integer, parameter :: nlevedgeforest_tmp = 3
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_a = (/ 1._r8, 1._r8, 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_b = (/ 1._r8, 1._r8, 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_c = (/ 1._r8, 1._r8, 1._r8 /)
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_nan = (/ nan, nan, nan /)
      logical :: norm = .true.
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin
      real(r8) :: expected = 1._r8 / real(nlevedgeforest_tmp, r8)

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           efb_params_nan, efb_params_nan, efb_params_nan, &
           efb_params_a, efb_params_b, efb_params_c, &
           fraction_forest_in_bin, norm)

      @assertEqual(expected, fraction_forest_in_bin(1), tol)
      @assertEqual(expected, fraction_forest_in_bin(2), tol)
      @assertEqual(expected, fraction_forest_in_bin(3), tol)

    end subroutine test_GetFracEdgeForestInEachBin_with_norm


    @Test
    subroutine test_GetFracEdgeForestInEachBin_x_near0(this)
      ! If frac forest is zero, all forest should be in first edge bin (closest to edge)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = nearzero / 2._r8
      integer, parameter :: nlevedgeforest_tmp = 3
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_dummy = (/ 1._r8, 2._r8, 3._r8 /)
      logical :: norm = .false.  ! Shouldn't matter for this test
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           fraction_forest_in_bin, norm)

      @assertEqual( (/ 1._r8, 0._r8, 0._r8 /) , fraction_forest_in_bin)

    end subroutine test_GetFracEdgeForestInEachBin_x_near0

    @Test
    subroutine test_GetFracEdgeForestInEachBin_x_near0_norm(this)
      ! If frac forest is zero, all forest should be in first edge bin (closest to edge)
      ! Same test as test_GetFracEdgeForestInEachBin_x_near0, except norm=.true.
      ! Shouldn't matter!
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = nearzero / 2._r8
      integer, parameter :: nlevedgeforest_tmp = 3
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_dummy = (/ 1._r8, 2._r8, 3._r8 /)
      logical :: norm = .true.  ! Shouldn't matter for this test
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           fraction_forest_in_bin, norm)

      @assertEqual( (/ 1._r8, 0._r8, 0._r8 /) , fraction_forest_in_bin)

    end subroutine test_GetFracEdgeForestInEachBin_x_near0_norm

    @Test
    subroutine test_GetFracEdgeForestInEachBin_x1(this)
      ! If frac forest is one, all forest should be in last edge bin ("deep forest")
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = 1._r8
      integer, parameter :: nlevedgeforest_tmp = 3
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_dummy = (/ 1._r8, 2._r8, 3._r8 /)
      logical :: norm = .false.  ! Shouldn't matter for this test
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           fraction_forest_in_bin, norm)

      @assertEqual( (/ 0._r8, 0._r8, 1._r8 /) , fraction_forest_in_bin)

    end subroutine test_GetFracEdgeForestInEachBin_x1

    @Test
    subroutine test_GetFracEdgeForestInEachBin_x1_norm(this)
      ! If frac forest is one, all forest should be in last edge bin ("deep forest").
      ! Same test as test_GetFracEdgeForestInEachBin_x1, except norm=.true.
      ! Shouldn't matter!
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: frac_forest = 1._r8
      integer, parameter :: nlevedgeforest_tmp = 3
      real(r8), dimension(nlevedgeforest_tmp) :: efb_params_dummy = (/ 1._r8, 2._r8, 3._r8 /)
      logical :: norm = .true.  ! Shouldn't matter for this test
      ! Output
      real(r8), dimension(nlevedgeforest_tmp) :: fraction_forest_in_bin

      call GetFracEdgeForestInEachBin(frac_forest, nlevedgeforest_tmp, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           efb_params_dummy, efb_params_dummy, efb_params_dummy, &
           fraction_forest_in_bin, norm)

      @assertEqual( (/ 0._r8, 0._r8, 1._r8 /) , fraction_forest_in_bin)

    end subroutine test_GetFracEdgeForestInEachBin_x1_norm

    @Test
    subroutine test_gffeb_lognorm_numerator(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x
      real(r8) :: A      ! Amplitude
      real(r8) :: mu     ! Center
      real(r8) :: sigma  ! Sigma
      real(r8) :: expected
      real(r8) :: actual
      logical  :: lognorm

      x = 10._r8
      ! Bin 4
      A = 1.601064269911203
      sigma = 0.8465094354405984
      mu = 1.973996133523811
      expected = 1.4848754270133655
      lognorm = .true.

      actual = GetFracEdgeForestInEachBin_norm_numerator(x, A, mu, sigma, lognorm)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_gffeb_lognorm_numerator

    @Test
    subroutine test_gffeb_gaussian_numerator(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x
      real(r8) :: A      ! Amplitude
      real(r8) :: mu     ! Center
      real(r8) :: sigma  ! Sigma
      real(r8) :: expected
      real(r8) :: actual
      logical  :: lognorm

      x = 0.87
      A = 2
      sigma = 3
      mu = 4
      expected = 1.160527865802580
      lognorm = .false.

      actual = GetFracEdgeForestInEachBin_norm_numerator(x, A, mu, sigma, lognorm)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_gffeb_gaussian_numerator

    @Test
    subroutine test_GetFracEdgeForestInEachBin_norm_lognorm(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x
      real(r8) :: A      ! Amplitude
      real(r8) :: mu     ! Center
      real(r8) :: sigma  ! Sigma
      real(r8) :: expected
      real(r8) :: actual
      logical  :: lognorm

      x = 0.87
      A = 2
      sigma = 3
      mu = 4
      expected = 0.11800808319557105
      lognorm = .true.

      actual = GetFracEdgeForestInEachBin_norm(x, A, mu, sigma, lognorm)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_GetFracEdgeForestInEachBin_norm_lognorm

    @Test
    subroutine test_GetFracEdgeForestInEachBin_norm_gaussian(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x
      real(r8) :: A      ! Amplitude
      real(r8) :: mu     ! Center
      real(r8) :: sigma  ! Sigma
      real(r8) :: expected
      real(r8) :: actual
      logical  :: lognorm

      x = 0.87
      A = 2
      sigma = 3
      mu = 4
      expected = 0.1543278780068184
      lognorm = .false.

      actual = GetFracEdgeForestInEachBin_norm(x, A, mu, sigma, lognorm)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_GetFracEdgeForestInEachBin_norm_gaussian

    @Test
    subroutine test_gffeb_lognorm_denominator(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x
      real(r8) :: A      ! Amplitude
      real(r8) :: mu     ! Center
      real(r8) :: sigma  ! Sigma
      real(r8) :: expected
      real(r8) :: actual
      logical  :: lognorm

      x = 10._r8
      ! Bin 4
      sigma = 0.8465094354405984
      expected = 21.21884485617329
      lognorm = .true.

      actual = GetFracEdgeForestInEachBin_norm_denominator(x, sigma, lognorm)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_gffeb_lognorm_denominator

    @Test
    subroutine test_gffeb_gaussian_denominator(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x
      real(r8) :: A      ! Amplitude
      real(r8) :: mu     ! Center
      real(r8) :: sigma  ! Sigma
      real(r8) :: expected
      real(r8) :: actual
      logical  :: lognorm

      x = 0.5_r8
      ! Bin 4
      sigma = 0.8465094354405984
      expected = 2.121884538742686
      lognorm = .false.

      actual = GetFracEdgeForestInEachBin_norm_denominator(x, sigma, lognorm)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_gffeb_gaussian_denominator

    @Test
    subroutine test_GetFracEdgeForestInEachBin_quadratic(this)
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: x = 0.4_r8
      real(r8) :: a = 1987._r8
      real(r8) :: b = 2025._r8
      real(r8) :: c = 1984._r8
      real(r8) :: expected = 3111.92_r8
      real(r8) :: actual

      actual = GetFracEdgeForestInEachBin_quadratic(x, a, b, c)

      @assertEqual(expected, actual, tolerance=tol)

    end subroutine test_GetFracEdgeForestInEachBin_quadratic

    @Test
    subroutine test_AssignPatchToBins_01(this)
      ! The site has just one forest patch. All of the site's forest area is in the bin closest to edge.
      class(TestEdgeForest), intent(inout) :: this
      integer, parameter :: nlevedgeforest_tmp = 3

      ! The site has 100 area of forest
      real(r8) :: area_forest_patches = 100._r8

      ! The size of this patch is 100 area
      real(r8) :: patch_area = 100._r8

      ! So far none of the site's forest area has been allocated to any bin
      real(r8) :: sum_forest_bins_so_far_m2 = 0._r8

      ! Out
      real(r8), dimension(nlevedgeforest_tmp) :: area_in_edgeforest_bins

      ! All of the site's forest is in the bin closest to edge
      real(r8), dimension(nlevedgeforest_tmp), target :: fraction_forest_in_each_bin
      fraction_forest_in_each_bin = (/ 1._r8, 0._r8, 0._r8 /)

      call AssignPatchToBins(fraction_forest_in_each_bin, area_forest_patches, patch_area, &
           nlevedgeforest_tmp, tol, sum_forest_bins_so_far_m2, area_in_edgeforest_bins)

      ! 0+100=100 area of the site's forest has been assigned after this call
      @assertEqual(100._r8, sum_forest_bins_so_far_m2, tolerance=tol)

      ! All of the patch's area was assigned to the first edge bin
      @assertEqual(100._r8, area_in_edgeforest_bins(1), tolerance=tol)
    end subroutine test_AssignPatchToBins_01

    @Test
    subroutine test_AssignPatchToBins_02(this)
      ! The site has multiple forest patches. All of the site's forest area is in the bin closest to edge.
      class(TestEdgeForest), intent(inout) :: this
      integer, parameter :: nlevedgeforest_tmp = 3

      ! The site has 300 area of forest
      real(r8) :: area_forest_patches = 300._r8

      ! The size of this patch is 100 area
      real(r8) :: patch_area = 100._r8

      ! So far none of the site's forest area has been allocated to any bin
      real(r8) :: sum_forest_bins_so_far_m2 = 0._r8

      ! Out
      real(r8), dimension(nlevedgeforest_tmp) :: area_in_edgeforest_bins

      ! All of the site's forest is in the bin closest to edge
      real(r8), dimension(nlevedgeforest_tmp), target :: fraction_forest_in_each_bin
      fraction_forest_in_each_bin = (/ 1._r8, 0._r8, 0._r8 /)

      call AssignPatchToBins(fraction_forest_in_each_bin, area_forest_patches, patch_area, &
           nlevedgeforest_tmp, tol, sum_forest_bins_so_far_m2, area_in_edgeforest_bins)

      ! 0+100=100 area of the site's forest has been assigned after this call
      @assertEqual(100._r8, sum_forest_bins_so_far_m2, tolerance=tol)

      ! All of the patch's area was assigned to the first edge bin
      @assertEqual(100._r8, area_in_edgeforest_bins(1), tolerance=tol)
      @assertEqual(0._r8, area_in_edgeforest_bins(2), tolerance=tol)
      @assertEqual(0._r8, area_in_edgeforest_bins(3), tolerance=tol)
    end subroutine test_AssignPatchToBins_02

    @Test
    subroutine test_AssignPatchToBins_03(this)
      ! The site has just one forest patch. The site's forest split evenly across the two bins closest to edge.
      class(TestEdgeForest), intent(inout) :: this
      integer, parameter :: nlevedgeforest_tmp = 3

      ! The site has 100 area of forest
      real(r8) :: area_forest_patches = 100._r8

      ! The size of this patch is 100 area
      real(r8) :: patch_area = 100._r8

      ! So far none of the site's forest area has been allocated to any bin
      real(r8) :: sum_forest_bins_so_far_m2 = 0._r8

      ! Out
      real(r8), dimension(nlevedgeforest_tmp) :: area_in_edgeforest_bins

      ! The site's forest split evenly across the two bins closest to edge
      real(r8), dimension(nlevedgeforest_tmp), target :: fraction_forest_in_each_bin
      fraction_forest_in_each_bin = (/ 0.5_r8, 0.5_r8, 0._r8 /)

      call AssignPatchToBins(fraction_forest_in_each_bin, area_forest_patches, patch_area, &
           nlevedgeforest_tmp, tol, sum_forest_bins_so_far_m2, area_in_edgeforest_bins)

      ! 0+100=100 area of the site's forest has been assigned after this call
      @assertEqual(100._r8, sum_forest_bins_so_far_m2, tolerance=tol)

      ! Half of the patch's area was assigned to the first edge bin, half to the second
      @assertEqual(50._r8, area_in_edgeforest_bins(1), tolerance=tol)
      @assertEqual(50._r8, area_in_edgeforest_bins(2), tolerance=tol)
      @assertEqual(0._r8, area_in_edgeforest_bins(3), tolerance=tol)
    end subroutine test_AssignPatchToBins_03

    @Test
    subroutine test_AssignPatchToBins_04(this)
      ! The site has just one forest patch. The site's forest is split evenly across the two bins farthest from edge.
      class(TestEdgeForest), intent(inout) :: this
      integer, parameter :: nlevedgeforest_tmp = 3

      ! The site has 100 area of forest
      real(r8) :: area_forest_patches = 100._r8

      ! The size of this patch is 100 area
      real(r8) :: patch_area = 100._r8

      ! So far none of the site's forest area has been allocated to any bin
      real(r8) :: sum_forest_bins_so_far_m2 = 0._r8

      ! Out
      real(r8), dimension(nlevedgeforest_tmp) :: area_in_edgeforest_bins

      ! The site's forest is split evenly across the two bins farthest from edge
      real(r8), dimension(nlevedgeforest_tmp), target :: fraction_forest_in_each_bin
      fraction_forest_in_each_bin = (/ 0._r8, 0.5_r8, 0.5_r8 /)

      call AssignPatchToBins(fraction_forest_in_each_bin, area_forest_patches, patch_area, &
           nlevedgeforest_tmp, tol, sum_forest_bins_so_far_m2, area_in_edgeforest_bins)

      ! 0+100=100 area of the site's forest has been assigned after this call
      @assertEqual(100._r8, sum_forest_bins_so_far_m2, tolerance=tol)

      ! Half of the patch's area was assigned to the second edge bin, half to the third
      @assertEqual(0._r8, area_in_edgeforest_bins(1), tolerance=tol)
      @assertEqual(50._r8, area_in_edgeforest_bins(2), tolerance=tol)
      @assertEqual(50._r8, area_in_edgeforest_bins(3), tolerance=tol)
    end subroutine test_AssignPatchToBins_04

    @Test
    subroutine test_AssignPatchToBins_05(this)
      ! The site has multiple forest patches. Some of the site's forest area has already been assigned. The patch isn't big enough to take the rest of the site's forest area.
      class(TestEdgeForest), intent(inout) :: this
      integer, parameter :: nlevedgeforest_tmp = 3

      ! The site has 100 area of forest
      real(r8) :: area_forest_patches = 100._r8

      ! The size of this patch is 50 area
      real(r8) :: patch_area = 50._r8

      ! So far 30 of the site's forest area has been allocated to any bin
      real(r8) :: sum_forest_bins_so_far_m2 = 30._r8

      ! Out
      real(r8), dimension(nlevedgeforest_tmp) :: area_in_edgeforest_bins

      ! The site's forest is split evenly across the two bins farthest from edge
      real(r8), dimension(nlevedgeforest_tmp), target :: fraction_forest_in_each_bin
      fraction_forest_in_each_bin = (/ 0._r8, 0.5_r8, 0.5_r8 /)

      call AssignPatchToBins(fraction_forest_in_each_bin, area_forest_patches, patch_area, &
           nlevedgeforest_tmp, tol, sum_forest_bins_so_far_m2, area_in_edgeforest_bins)

      ! 30+50=80 area of the site's forest has been assigned after this call
      @assertEqual(80._r8, sum_forest_bins_so_far_m2, tolerance=tol)

      ! Some of the patch's area was assigned to the second edge bin, rest to the third
      @assertEqual(0._r8, area_in_edgeforest_bins(1), tolerance=tol)
      @assertEqual(20._r8, area_in_edgeforest_bins(2), tolerance=tol)
      @assertEqual(30._r8, area_in_edgeforest_bins(3), tolerance=tol)
    end subroutine test_AssignPatchToBins_05

    @Test
    subroutine test_calculate_edgeforest_flammability_onevar_onebin(this)
      ! Test applying a flammability enhancement to one variable for one edge bin
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: mult_factor = 2._r8
      real(r8) :: add_factor = 3._r8
      real(r8) :: weather_in = 5._r8
      real(r8) :: weather_out

      weather_out = calculate_edgeforest_flammability_onevar_onebin(mult_factor, add_factor, weather_in)

      @assertEqual(13._r8, weather_out, tolerance=tol)
    end subroutine test_calculate_edgeforest_flammability_onevar_onebin

    @Test
    subroutine test_calculate_edgeforest_flammability_onevar_onebin_nochange(this)
      ! Test applying a flammability enhancement to one variable for one edge bin, expecting no change
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: mult_factor = 1._r8
      real(r8) :: add_factor = 0._r8
      real(r8) :: weather_in = 5._r8
      real(r8) :: weather_out

      weather_out = calculate_edgeforest_flammability_onevar_onebin(mult_factor, add_factor, weather_in)

      @assertEqual(5._r8, weather_out, tolerance=0._r8)
    end subroutine test_calculate_edgeforest_flammability_onevar_onebin_nochange

    @Test
    subroutine test_calculate_edgeforest_flammability_onevar(this)
      ! Test applying a flammability enhancement to one variable for multiple edge bins
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: mult_factors(2) = [2._r8, 0.4_r8]
      real(r8) :: add_factors(2) = [3._r8, -1._r8]
      real(r8) :: weather_in = 5._r8
      real(r8) :: weather_out(2)

      call calculate_edgeforest_flammability_onevar(mult_factors, add_factors, weather_in, weather_out)

      @assertEqual(13._r8, weather_out(1), tolerance=tol)
      @assertEqual(1._r8, weather_out(2), tolerance=tol)
    end subroutine test_calculate_edgeforest_flammability_onevar

    @Test
    subroutine test_calculate_edgeforest_flammability_onevar_nochange(this)
      ! Test applying a flammability enhancement to one variable for multiple edge bins, expecting no change
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: mult_factors(2) = [1._r8, 1._r8]
      real(r8) :: add_factors(2) = [0._r8, 0._r8]
      real(r8) :: weather_in = 5._r8
      real(r8) :: weather_out(2)

      call calculate_edgeforest_flammability_onevar(mult_factors, add_factors, weather_in, weather_out)

      @assertEqual(5._r8, weather_out(1), tolerance=tol)
      @assertEqual(5._r8, weather_out(2), tolerance=tol)
    end subroutine test_calculate_edgeforest_flammability_onevar_nochange

    @Test
    subroutine test_apply_ef_flam_2patch_onevar_noforest(this)
      ! Test applying a flammability enhancement to one patch with no forest
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: weather_by_edge_bin(3) = [2._r8, 2._r8, 10._r8]
      real(r8) :: patch_area_each_edge_bin(3) = [0._r8, 0._r8, 0._r8]
      real(r8) :: weather_inout = 5._r8

      call apply_edgeforest_flammability_to_patch_onevar(weather_by_edge_bin, patch_area_each_edge_bin, weather_inout)

      @assertEqual(5._r8, weather_inout, tolerance=0._r8)
    end subroutine test_apply_ef_flam_2patch_onevar_noforest

    @Test
    subroutine test_apply_ef_flam_2patch_onevar_1bin(this)
      ! Test applying a flammability enhancement to one patch with forest in 1 bin
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: weather_by_edge_bin(3) = [2._r8, 2._r8, 5._r8]
      real(r8) :: patch_area_each_edge_bin(3) = [16._r8, 0._r8, 0._r8]
      real(r8) :: weather_inout = 5._r8

      call apply_edgeforest_flammability_to_patch_onevar(weather_by_edge_bin, patch_area_each_edge_bin, weather_inout)

      @assertEqual(2._r8, weather_inout, tolerance=tol)
    end subroutine test_apply_ef_flam_2patch_onevar_1bin

    @Test
    subroutine test_apply_ef_flam_2patch_onevar_allbins(this)
      ! Test applying a flammability enhancement to one patch with forest in all bins
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: weather_by_edge_bin(3) = [2._r8, 2._r8, 9._r8]
      real(r8) :: patch_area_each_edge_bin(3) = [16._r8, 32._r8, 64._r8]
      real(r8) :: weather_inout = 9._r8

      call apply_edgeforest_flammability_to_patch_onevar(weather_by_edge_bin, patch_area_each_edge_bin, weather_inout)

      @assertEqual(6._r8, weather_inout, tolerance=tol)
    end subroutine test_apply_ef_flam_2patch_onevar_allbins

    @Test
    subroutine test_apply_ef_flam_2patch_onevar_allbins_nochange(this)
      ! Test applying a flammability enhancement to one patch with forest in all bins, expecting no change
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: weather_by_edge_bin(3) = [9._r8, 9._r8, 9._r8]
      real(r8) :: patch_area_each_edge_bin(3) = [1.e-30_r8, 32._r8, 64._r8]
      real(r8) :: weather_inout = 9._r8

      call apply_edgeforest_flammability_to_patch_onevar(weather_by_edge_bin, patch_area_each_edge_bin, weather_inout)

      @assertEqual(9._r8, weather_inout, tolerance=0._r8)
      
      @assertTrue(all([9._r8, 9._r8, 9._r8] == 9._r8))
    end subroutine test_apply_ef_flam_2patch_onevar_allbins_nochange

    @Test
    subroutine test_check_change_intended_true_justadd(this)
      ! Test check_change_intended() returning false with only additive changes
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: params_mult(3) = [1._r8, 1._r8, 1._r8]
      real(r8) :: params_add(3) = [1.e-30_r8, 32._r8, 64._r8]
      real(r8) :: weather_before = 9._r8
      real(r8) :: weather_after = 10._r8
      real(r8) :: tol2 = 1.e-9_r8

      @assertTrue(check_change_intended(params_mult, params_add, weather_before, weather_after, tol2))

    end subroutine test_check_change_intended_true_justadd

    @Test
    subroutine test_check_change_intended_true_justadd_neg(this)
      ! Test check_change_intended() returning false with only negative additive changes
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: params_mult(3) = [1._r8, 1._r8, 1._r8]
      real(r8) :: params_add(3) = [-1.e-30_r8, -32._r8, -64._r8]
      real(r8) :: weather_before = 9._r8
      real(r8) :: weather_after = 10._r8
      real(r8) :: tol2 = 1.e-9_r8

      @assertTrue(check_change_intended(params_mult, params_add, weather_before, weather_after, tol2))

    end subroutine test_check_change_intended_true_justadd_neg

    @Test
    subroutine test_check_change_intended_true_justmult(this)
      ! Test check_change_intended() returning false with only multiplicative changes
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: params_mult(3) = [1.2_r8, 1.3_r8, 1.4_r8]
      real(r8) :: params_add(3) = [0._r8, 0._r8, 0._r8]
      real(r8) :: weather_before = 9._r8
      real(r8) :: weather_after = 10._r8
      real(r8) :: tol2 = 1.e-9_r8

      @assertTrue(check_change_intended(params_mult, params_add, weather_before, weather_after, tol2))

    end subroutine test_check_change_intended_true_justmult

    @Test
    subroutine test_check_change_intended_true_justmult_neg(this)
      ! Test check_change_intended() returning false with only negative multiplicative changes
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: params_mult(3) = [-1.2_r8, -1.3_r8, -1.4_r8]
      real(r8) :: params_add(3) = [0._r8, 0._r8, 0._r8]
      real(r8) :: weather_before = 9._r8
      real(r8) :: weather_after = 10._r8
      real(r8) :: tol2 = 1.e-9_r8

      @assertTrue(check_change_intended(params_mult, params_add, weather_before, weather_after, tol2))

    end subroutine test_check_change_intended_true_justmult_neg

    @Test
    subroutine test_check_change_intended_true_both(this)
      ! Test check_change_intended() returning false with both additive and multiplicative changes
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: params_mult(3) = [1.2_r8, 1.3_r8, 1.4_r8]
      real(r8) :: params_add(3) = [0._r8, 2._r8, 22._r8]
      real(r8) :: weather_before = 9._r8
      real(r8) :: weather_after
      real(r8) :: tol2 = 1.e-9_r8

      ! Check that tolerance works
      weather_after = weather_before + tol * (1._r8 + tol * 1.e-3_r8)

      @assertTrue(check_change_intended(params_mult, params_add, weather_before, weather_after, tol2))

    end subroutine test_check_change_intended_true_both

    @Test
    subroutine test_check_change_intended_false(this)
      ! Test check_change_intended() returning false with neither additive nor multiplicative changes
      class(TestEdgeForest), intent(inout) :: this
      real(r8) :: params_mult(3) = [1._r8, 1._r8, 1._r8]
      real(r8) :: params_add(3) = [0._r8, 0._r8, 0._r8]
      real(r8) :: weather_before = 9._r8
      real(r8) :: weather_after
      real(r8) :: tol2 = 1.e-9_r8

      ! Check that tolerance works
      weather_after = weather_before + tol * 1.e-3_r8

      @assertFalse(check_change_intended(params_mult, params_add, weather_before, weather_after, tol2))

    end subroutine test_check_change_intended_false

  end module test_EdgeForest
